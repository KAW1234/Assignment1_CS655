How Flexcible is your implementation
I believe my implementation is very flexible. I created a abstract superclass that handles most of the functionality in the assignement like add_milk() and add_sugar(). From there, the rest of the subclasses, which are the various amounts of beverages, inherit it. This greatly simplifies the amount of code needed in each class, since the majority of the functions needed are in the abstract class. This not only makes it simple to read but also easy to add or remove other beverages. If I needed to add a beverage to the machine, I would simply create another class of that beverage, inherit the abstract class that contains all the functions that contains functionality, and then simply create set a base price for said beverages. The abstract class will handles coutning how many condiments the customer added as well as calculating the price of the final beverage

How is simplicity and understandability of your implementation?
Since I used a superclass to handle all the functions, most classes at most have 3 methods inside of them. These methods are simply there to set the price of the beverage and to return the final price of the beverage. Due to the limited amount of methods, there isnt much clutter on the screen. So simplicity and understandability is acceptional. The only class that might cause some trouble is the superclass, due to it handling most of the functionality. Even then, the amount of functions and varibales in there are self explanatory.

How you avoided duplicated code
By using a superclass that most of the work, and simply created subclasses that inherited from that superclass, I removed alot of rewritting the same code over and over again. While, at the same time, maintaining functionality of the other classes.

Assumption
For this project I assumed that some other programmer dealt with the GUI and the user-interface of this software. Therefore, meaning I only had to handle the backend functions. I also assumed that the mechanical engineer created the machine itself and the mechanical functions of the coffee machine, such as dispensing the liquid and supllying the cups. I assumed that the user has already selected thier beverage, which is why in the created class objects have the beverage name already supplied. For example, the user would type in mocha and the code will look something like "Beverage mocha = new Mocha("Mocha"). Essentially, an object of that type beverage has already been made since the user entered thier beverage type. Im also assuming the functionality of this coffee machine works one at a time. What I mean is that a person cannot request for more than one bevergae at the same time since the creation of the beverage would happen after the beverage is paid for. Similiar to how coffee machine work in the real world, one person cannot order two beverage at the same time. He or she must enter their beverage again if they want a second one.

Design Pattern
No design patterns were needed so no design patterns were used.

Main Software design patterns
Essentially I wanted to create a project that was easy to read and manipulate. I found the best way to achieve this was by having a superclass that handles most of the work, then having subclasses inherit that superclass when I wanted the subclasses to use the functions from the superclass. I made the superclass abstract so the subclasses can override certain functions of the superclass when needed be, like the function get_price() and calculate_price() which returns the price of the specific drink. This was because the each drink had a specific price, that was different than the others. This implementation also made it easier to make changes. All a developer would need to do is to either delete or create a subclass with the beverage name, inherit the superclass 'Beverage', then ovveride the methods final_price(), get_price, and calculate_price() in the class. All in all, I feel like this was the easiest and most practical way to solve this problem.
